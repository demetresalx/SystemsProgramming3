# 3rd System Programming Assignment 2020
**D. Alexandres, 1115201400006.**
Third (3rd) assignment on UNIX system programming,
*University of Athens, 2020.*

Υλοποιήθηκε με C++ σε Ubuntu 16.04 LTS και δοκιμάστηκε σε μηχάνημα της σχολής.
Όλα τα ερωτήματα/εντολές έχουν υλοποιηθεί.

Το master πρόγραμμα ξεκινά τον απαιτούμενο αριθμό workers και τους μοιράζει
τα directores ομοιόμορφα ακριβώς όπως στη 2η εργασία μέσω named pipes.
Παραμένει ζωντανό ώστε να χειρίζεται το SIGCHLD σήμα και να αναγεννά παιδιά-workers όταν κάποιο από
τα υπάρχοντα τερματίσει ξαφνικά. Για έξοδο/τερματισμό του master προγράμματος, αρκεί ctr-C (SIGINT) στον master
και αυτός θα φροντίσει να κάνει SIGKILL και τα παιδιά.

Το κάθε worker process στη συνέχεια δημιουργεί ενα sockaddr_in με port το 0
ώστε να του ανατεθεί μετά ενα διαθέσιμο νούμερο πόρτας για να το στείλει στον whoServer.

Ο circular buffer ειναι ΟΠΩΣ ΣΤΙΣ ΔΙΑΦΑΝΕΙΕΣ. Υπάρχει η κλάση pool(αντιστοιχη της struct pool των διαφανειών του κ. Ντούλα) που κρατάει:
1. τον πίνακα απο fds που ζητείται *
2. το start
3. το end
4. το count
* ο πίνακας αυτός αντί για ένα σκέτο fd έχει μέσα και το τι είδους fd είναι (query or statistics) για να κατατοπίζει τα threads σωστά.
Λειτουργεί όπως στις διαφάνειες με producer τον server που κάνει accept και consumers τα threads του που αναλαμβάνουν να τα εξυπηρετήσουν.
----------ΠΡΩΤΟΚΟΛΛΟ ΕΠΙΚΟΙΝΩΝΙΑΣ ΜΕΣΩ SOCKETS------------
Ίδιο με τα named pipes της 2η εργασίας. Όπως είχα εξηγήσει και εκεί, έχω φτιάξει τις συναρτήσεις
send_string, receive_string που χρησιμοποιούν ΑΠΟΚΛΕΙΣΤΙΚΑ ΤΙΣ LOW LEVEL CALLS READ & WRITE.
Στέλνεται ένας ακέραιος που είναι το μέγεθος του μηνύματος πρώτα και μετά το μήνυμα.
Έχω και έκδοσή τους για std::string της c++ αλλά και πάλι σε επίπεδο sockets/pipes γίνεται με char * (δε γινεται και αλλιώς).
Βασίζονται και πάλι στις readall, writeall της αμερικάνικης έκδοσης του βιβλίου που κατέβασα από το ίντερνετ μια και δεν έχω το κανονικό βιβλίο.
(Marc J. Rochkind - Advanced UNIX Programming (2004, Addison-Wesley Professional) - selida 97).
Η διαφορά με τη 2η άσκηση είναι ότι για να καλύπτω όλες τις ασυμφωνίες αρχιτεκτονικής
μεταξύ απομακρυσμένων μηχανημάτων, ο ακέραιος που στέλνω πριν το μήνυμα δεν είναι int αλλά int32_t
και τον περνάω απο htonl στον writer. O reader τον κάνει ntohl αφού τον διαβάσει.
Με αυτόν τον τρόπο εξασφαλίζεται οτι θα διαβαστεί σωστά.
Έφτιαξα και τις send_integer, receive_integer που είναι μόνο για μεταφορά αριθμών με τον ίδιο τρόπο.
Εάν ο client λάβει ενα ερώτημα κακώς διατυπωμένο, δε θα το προωθήσει στον server kαι θα δώσει σχετικό μήνυμα λάθους.

------------ΣΥΓΧΡΟΝΙΣΜΟΣ ΝΗΜΑΤΩΝ-----------------
Η κλάση synchro_stdout συγχρονίζει την εκτύπωση των threads στο stdout.
Με τις συναρτήσεις cs_start & cs_end δημιουργεί την αρχή και το τέλος ενός critical
section στο stdout ώστε να εκτυπώνει ενα thread τη φορά
και να μην είναι συγκεχυμένο το output στην οθόνη.
