# 3rd System Programming Assignment 2020
**D. Alexandres, 1115201400006.**
Third (3rd) assignment on UNIX system programming,
*University of Athens, 2020.*

Υλοποιήθηκε με C++ σε Ubuntu 16.04 LTS και δοκιμάστηκε σε μηχάνημα της σχολής.
Όλα τα ερωτήματα/εντολές έχουν υλοποιηθεί.

Το master πρόγραμμα ξεκινά τον απαιτούμενο αριθμό workers και τους μοιράζει
τα directores ομοιόμορφα ακριβώς όπως στη 2η εργασία μέσω named pipes.
Παραμένει ζωντανό ώστε να χειρίζεται το SIGCHLD σήμα και να αναγεννά παιδιά-workers όταν κάποιο από
τα υπάρχοντα τερματίσει ξαφνικά. Για έξοδο/τερματισμό του master προγράμματος, αρκεί ctr-C (SIGINT) στον master
και αυτός θα φροντίσει να κάνει SIGKILL και τα παιδιά.

Το κάθε worker process στη συνέχεια δημιουργεί ενα sockaddr_in με port το 0
ώστε να του ανατεθεί μετά ενα διαθέσιμο νούμερο πόρτας για να το στείλει στον whoServer.

Ο circular buffer ειναι ΟΠΩΣ ΣΤΙΣ ΔΙΑΦΑΝΕΙΕΣ. Υπάρχει η κλάση pool(αντιστοιχη της struct pool των διαφανειών του κ. Ντούλα) που κρατάει:
1. τον πίνακα απο fds που ζητείται
2. το start
3. το end
4. το count

----------ΠΡΩΤΟΚΟΛΛΟ ΕΠΙΚΟΙΝΩΝΙΑΣ ΜΕΣΩ SOCKETS------------
Ίδιο με τα named pipes της 2η εργασίας. Όπως είχα εξηγήσει και εκεί, έχω φτιάξει τις συναρτήσεις
send_string, receive_string που χρησιμοποιούν ΑΠΟΚΛΕΙΣΤΙΚΑ ΤΙΣ LOW LEVEL CALLS READ & WRITE.
Στέλνεται ένας ακέραιος που είναι το μέγεθος του μηνύματος πρώτα και μετά το μήνυμα.
Έχω και έκδοσή τους για std::string της c++ αλλά και πάλι σε επίπεδο sockets/pipes γίνεται με char * (δε γινεται και αλλιώς).
Βασίζονται και πάλι στις readall, writeall της αμερικάνικης έκδοσης του βιβλίου που κατέβασα από το ίντερνετ μια και δεν έχω το κανονικό βιβλίο.
(Marc J. Rochkind - Advanced UNIX Programming (2004, Addison-Wesley Professional) - selida 97).
Η διαφορά με τη 2η άσκηση είναι ότι για να καλύπτω όλες τις ασυμφωνίες αρχιτεκτονικής μεταξύ απομακρυσμένων μηχανημάτων,
ο ακέραιος που στέλνω πριν το μήνυμα δεν είναι int αλλά int32_t και τον περνάω απο htonl στον writer. O reader τον κάνει ntohl αφού τον διαβάσει.
Με αυτόν τον τρόπο εξασφαλίζεται οτι θα διαβαστεί σωστά.
Έφτιαξα και τις send_integer, receive_integer που είναι μόνο για μεταφορά αριθμών με τον ίδιο τρόπο.
